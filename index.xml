<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jin</title>
    <link>https://lochjin.github.io/</link>
    <description>Recent content on Jin</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>© Copyright</copyright>
    <lastBuildDate>Thu, 12 Dec 2019 20:34:58 +0800</lastBuildDate>
    
	<atom:link href="https://lochjin.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Decentralized Mining Pools</title>
      <link>https://lochjin.github.io/posts/miningpools/</link>
      <pubDate>Thu, 12 Dec 2019 20:34:58 +0800</pubDate>
      
      <guid>https://lochjin.github.io/posts/miningpools/</guid>
      <description>Problem   Mining in Cryptocurrencies is Highly Centralized
 More than 80% of mining power in Ethereum emanates from 5 mining pools. Similarly, the main 8 pools control the same fraction of mining power in Bitcoin.    Transaction Censorship and Single Point of Failure
 Pools dictate the transaction sets in new blocks, not miners. Pools are subject to continuous DDoS attacks. If a big pool goes down, the security of the network is significantly compromised.</description>
    </item>
    
    <item>
      <title>Oracle</title>
      <link>https://lochjin.github.io/posts/humanoracle/</link>
      <pubDate>Sat, 13 Jul 2019 10:01:58 +0800</pubDate>
      
      <guid>https://lochjin.github.io/posts/humanoracle/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://lochjin.github.io/img/2019/oracle.jpeg&#34; alt=&#34;oracle&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;像以太坊、EOS这样的区块链网络没有直接的途径来获取链外的信息，所以也就没有办法获取和验证触发智能合约的条件，那么我们设想的智能合约自动执行法律文件、履行商务合同、进行防伪溯源和征信验证等所有应用领域的功能可能都无法实现。这就是需要预言机的时刻了，简单地说，区块链预言机，就是一个提供外部信息的平台。预言机自身也是一种智能合约，它允许区块链连接到任何现有的API，允许使用来自区块链的传统支付网络来进行支付，并允许智能合约和其他区块链的交互。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Prisoner&#39;s Dilemma</title>
      <link>https://lochjin.github.io/posts/prisoner-dilemma/</link>
      <pubDate>Thu, 02 May 2019 10:34:58 +0800</pubDate>
      
      <guid>https://lochjin.github.io/posts/prisoner-dilemma/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://lochjin.github.io/img/2019/pd.jpg&#34; alt=&#34;prisoner&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;囚徒困境是博弈论的非零和博弈中具代表性的例子，反映个人最佳选择并非团体最佳选择。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Memory-hard puzzles</title>
      <link>https://lochjin.github.io/posts/memeory-hard-puzzles/</link>
      <pubDate>Sat, 27 Apr 2019 09:31:58 +0800</pubDate>
      
      <guid>https://lochjin.github.io/posts/memeory-hard-puzzles/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://lochjin.github.io/img/2019/mhp.jpeg&#34; alt=&#34;asic&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;刚性内存解谜（Memory-hard puzzles）需要大量的内存计算，而不是靠大量的CPU时间&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Polkadot</title>
      <link>https://lochjin.github.io/posts/polkadot/</link>
      <pubDate>Fri, 26 Apr 2019 08:12:58 +0800</pubDate>
      
      <guid>https://lochjin.github.io/posts/polkadot/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://lochjin.github.io/img/2019/polkadot.jpg&#34; alt=&#34;polkadot&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Polkadot is a heterogeneous multi‑chain technology.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>基于HTTPS的DNS</title>
      <link>https://lochjin.github.io/posts/dns-over-https/</link>
      <pubDate>Tue, 23 Apr 2019 14:01:58 +0800</pubDate>
      
      <guid>https://lochjin.github.io/posts/dns-over-https/</guid>
      <description>Mozilla和Cloudflare合作提供的一项新的 IETF 标准方案可信递归解析器，一种新的解决 DNS 安全的方案
最近用了下Firefox浏览器的这个功能，感觉还蛮强大的。同时也发现个诡异的问题，使用VPN的时候只有开启这个功能的时候才可以访问google。
什么是 HTTP？ 当我们解释浏览器如何下载网页时，通常会这样解释：浏览器向服务器发出 GET 请求。服务器发送一个响应，该响应是一个包含 HTML 的文件。这个系统被称为 HTTP。 什么是 DNS？ 域名系统（DNS）就是将站点名称转换为 IP 地址的系统，而将域名转换为 IP 地址的过程，称为域名解析。 DNS 如何被利用？ 通常解析器会告诉每个 DNS 服务器你正在寻找哪个域名。 该请求有时会包含你的完整 IP 地址。 或者，如果不是完整的 IP 地址，请求中通常会包含你的大部分 IP 地址，这些 IP 地址可以轻松地与其他信息结合起来以找出你的身份。这意味着进行域名解析的每台服务器都会查看你要查找的网站。 但更重要的是，这也意味着通往这些服务器的任何人都可以看到你的请求。这个系统有几种方式会使用户的数据处于危险之中。 两大主要的风险是跟踪和欺骗攻击。
  跟踪     欺骗   Cloudflare与Mozilla致力于构建隐私优先的 DNS 服务。合作建立了一个 DoH 解决方案服务。</description>
    </item>
    
    <item>
      <title>Conflux共识机制介绍</title>
      <link>https://lochjin.github.io/posts/conflux/</link>
      <pubDate>Mon, 22 Apr 2019 11:12:58 +0800</pubDate>
      
      <guid>https://lochjin.github.io/posts/conflux/</guid>
      <description>Conflux共识机制的吞吐量能达到5.78GB/s，确认时间4.5-7.4分钟，交易速度6000TPS。Conflux共识机制的交易速度是GHOST或者Bitcoin的11.62倍，Algorand的3.84倍。
 本文引用原始地址  Conflux框架 Conflux共识机制是在比特币源代码基础上实现的。Conflux的框架和比特币的矿机类似：GossipNetwork实现P2P网络交互，节点维护TxPool，生成区块（Block Generator），以及维护区块状态。Conflux框架如下图： 框架图中的虚线部分是一个节点上的细节。比特币的区块链是一条链，也就是说，每个区块只有一个父区块。和比特币不同，Conflux的区块链是由“DAG State”实现，每个区块除了一个“父区块”外，可能还有多个“引用区块”。
区块DAG Conflux中的区块之间由多条边（Edge，连接）组成，这些边分成两类：父连接，以及引用连接。在确定主链（Pivot）的基础上，新生成的区块必须使用父连接连接到主链的最后一个区块上。除了主链外，还存在其他一些非主链的路径，新生成的区块必须使用“引用连接”连接这些非主链的最后一个区块。也就是说，Conflux中的区块之间的连接关系组成DAG（有向无环图）。Conflux中组成DAG的区块会确定一条主链（Pivot Chain）。在主链确定的基础上再确定所有区块的先后顺序。区块DAG的示意图如下： Genesis是“创世纪”块，也就是第一个块。父连接用“实心”箭头表示，引用连接用“虚线”箭头表示。区块C使用“父连接”连接到A，使用“引用连接”连接到B。新生成的区块（New Block）使用“父连接”连接到H，使用“引用连接”连接到K。
总结 Conflux共识机制，借鉴了2015年论文中的GHOST规则，使用DAG数据结构组织区块。论文逻辑清晰，比较容易阅读。Conflux共识机制，在DAG区块中，先使用GHOST规则确定主链，再确定区块顺序，交易顺序。发生冲突的交易，只保留第一个交易，其他冲突交易作废。论文论证了Conflux共识机制，保证了区块的安全性和可靠性，又能极大地提升交易吞吐量。实验数据表明：Conflux共识机制的吞吐量能达到5.78GB/s，确认时间4.5-7.4分钟，交易速度6000TPS。</description>
    </item>
    
    <item>
      <title>Mathpix Snip</title>
      <link>https://lochjin.github.io/posts/snip/</link>
      <pubDate>Fri, 01 Mar 2019 09:31:58 +0800</pubDate>
      
      <guid>https://lochjin.github.io/posts/snip/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://lochjin.github.io/img/2019/snip.jpg&#34; alt=&#34;snip&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;convert-images-to-latex&#34;&gt;Convert images to LaTeX&lt;/h2&gt;
&lt;p&gt;Take a screenshot of math and paste the LaTeX into your editor, all with a single keyboard shortcut.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>XDAG:A new DAG-based cryptocurrency</title>
      <link>https://lochjin.github.io/posts/xdag/</link>
      <pubDate>Wed, 02 Jan 2019 10:01:58 +0800</pubDate>
      
      <guid>https://lochjin.github.io/posts/xdag/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://lochjin.github.io/img/2019/xdag.jpg&#34; alt=&#34;dag&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;XDAG is a novel application of Directed Acyclic Graph(DAG) technology that solves the issues currently facing blockchain technology.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>财货</title>
      <link>https://lochjin.github.io/posts/caihuo/</link>
      <pubDate>Sun, 01 Jul 2018 10:34:58 +0800</pubDate>
      
      <guid>https://lochjin.github.io/posts/caihuo/</guid>
      <description>在1871年发表的《国民经济学原理》中，门格尔把财货称为“Goods”，就是“善”，或叫商品，不同于斯密的Wealth——这里的Goods是非价值形态的实物。
在讨论财货时，我们先去掉价格因素，只讨论它的物理形态，然后讨论价值形态。门格尔在第一章“财货的一般理论”里，把Goods定义为“有用的物品”，有用物品需要满足下面四项原则或性质，缺一不可，这四项性质联合定义了门格尔意义上的实物形态的财货。
 一物要成为财货，需要满足的第一个前提是，它对应着我们的某些欲望。 第二个要素是这个事物虽然对应着我们的某些欲望，如果不存在客观的因果关系链，让它能够满足我们的欲望，那就 不能构成门格尔意义上的财货，这也很直观。 第三个要素是最重要的，这是奥地利学派不同于芝加哥学派的出发点， 从奥地利学派的创始人开始，就侧重于经济学的认识论。即，我们要认识到客观存在的因果关系。如果我们没有认识到虾能够提供蛋白质，能满足你的某种生存欲望，那就不会吃虾，就如同非洲的某些原始部落那样。 第四个要素是此物可支配，这也符合我们的直观。月亮或火星上的土地，对于现在的我们来说不能算作财货，因为我们无法对它行使支配权。这四个要素联合起来，构成了财货的基本条件。  </description>
    </item>
    
    <item>
      <title>Selfish Mining</title>
      <link>https://lochjin.github.io/posts/selfishmining/</link>
      <pubDate>Fri, 01 Jun 2018 13:31:58 +0800</pubDate>
      
      <guid>https://lochjin.github.io/posts/selfishmining/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://lochjin.github.io/img/2018/selfishmining.jpg&#34; alt=&#34;mining&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;自私挖矿攻击是一种针对比特币挖矿与激励机制的攻击方式，它的目的不是破坏比特币的运行机制，而是获取额外的奖励，并让诚实矿工进行无效计算。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>比特币之Bloom过滤器</title>
      <link>https://lochjin.github.io/posts/bloom/</link>
      <pubDate>Fri, 02 Mar 2018 10:01:58 +0800</pubDate>
      
      <guid>https://lochjin.github.io/posts/bloom/</guid>
      <description>简介 Bloom过滤器是一个允许用户描述特定的关键词组合而不必精确表述的基于概率的过滤方法。它能让用户在有效搜 索关键词的同时保护他们的隐私。在SPV节点里，这一方法被用来向对等节点发送交易信息查询请求，同时交易地址不会被暴露。
其实通俗的理解，就是说比如你现在正在上海旅游，正好你不知道怎么去“南京路步行街”。如果你直接向迎面而来的陌生人说“请问南京路步行街在哪里”，这样岂不是一下子就暴露了你想要去的目的地，岂不是毫无隐私而言。所以如果是换成Bloom过滤器的话，就会是这样：附近带“京”字的马路是什么，然后你会得到一些结果，可能里面会有很多你不想要的，没有关系，你可以再次询问附近的”步行街“有哪些，最后一步步得到你要的结果。这种方式虽然是拐着弯在询问，但是很好的保护了用户的隐私。
Bloom过滤器可以让SPV节点指定交易的搜索模式，该搜索模式可以基于准确性或私密性的考虑被调节。一个非常具体的Bloom过滤器会生成更准确的结果，但也会显示该用户钱包里的使用的地址;反之，如果过滤器只包含简单的关键词，更多相应的交易会被搜索出来，在包含若干无关交易的同时有着更高的私密性。
工作原理 Bloom过滤器的实现是由一个可变长度(N)的二进制数组(N位二进制数构成一个位域)和数量可变(M)的一组哈希函数组成。这些哈希函数的输出值始终在1和N之间，该数值与二进制数组相对应。并且该函数为确定性函数，也就是说任何一个使用相同Bloom过滤器的节点通过该函数都能对特定输入得到同一个的结果。Bloom过滤器的准确性和私密性能通过改变长度(N)和哈希函数的数量(M)来调节。 在下图中，我们用一个小型的十六位数组和三个哈希函数来演示Bloom过滤器的应用原理。
Bloom过滤器数组里的每一个数的初始值为零。关键词被加到Bloom过滤器中之前，会依次通过每一个哈希函数运算一次。该输入经第一个哈希函数运算后得到了一个在1和N之间的数，它在该数组(编号依次为1至N)中所对应 的位被置 为1，从而把哈希函数的输出记录下来。接着再进行下一个哈希函数的运算，把另外一位置为1;以此类 推。当全部M个 哈希函数都运算过之后，一共有M个位的值从0变成了1，这个关键词也被“记录”在了Bloom过滤器里。 下图显示了向Bloom过滤器添加关键词“A”。
增加第二个关键是就是简单地重复之前的步骤。关键词依次通过各哈希函数运算之后，相应的位变为1，Bloom过滤器则记录下该关键词。需要注意的是，当Bloom过滤器里的关键词增加时，它对应的某个哈希函数的输出值的位可能已经是1了，这种情况下，该位不会再次改变。也就是说，随着更多的关键词指向了重复的位，Bloom过滤器随着位1的增加而饱和，准确性也因此降低了。该过滤器之所以是基于概率的数据结构，就是因为关键词的增加会导致准确性的降低。 准确性取决于关键字的数量以及数组大小(N)和哈希函数的多少(M)。更大的数组和更多的哈希函数会记录更多的关键词以提高准确性。而小的数组及有限的哈希函数只能记录有限的关键词从而降低准 确性。 下图显示了向该简易Bloom过滤器里增加第二个关键词“B”。
为测试某一关键词是否被记录在某个Bloom过滤器中，我们将该关键词逐一代入各哈希函数中运算，并将所得的结果与原数组进行对比。如果所有的结果对应的位都变为了1，则表示这个关键词有可能已被该过滤器记录。之所以这一结论并不确定，是因为这些字节1也有可能是其他关键词运算的重叠结果。简单来说，Bloom过滤器正匹配代表着“可能是”。下图是一个验证关键词“X”是否在前述Bloom过滤器中的图例。相应的比特位都被置为1，所以这个关键词很有可能是匹配的。
另一方面，如果我们代入关键词计算后的结果某位为0，说明该关键词并没有被记录在过滤器里。负匹配的结果不是可能，而是一定。也就是说，负匹配代表着“一定不是”。下图是一个验证关键词“Y”是否存在于简易Bloom过滤器中的图例。图中某个结果字段为0，该字段一定没有被匹配。
这种保护隐私的方法可以在很多场景中得到应用。</description>
    </item>
    
    <item>
      <title>DDoS攻击</title>
      <link>https://lochjin.github.io/posts/ddos/</link>
      <pubDate>Fri, 02 Feb 2018 10:25:58 +0800</pubDate>
      
      <guid>https://lochjin.github.io/posts/ddos/</guid>
      <description>根据卡巴斯基2016Q3的调查报告，DDoS攻击造成61%的公司无法访问其关键业务信息，38%公司无法访问其关键业务，33%的受害者因此有商业合同或者合同上的损失。
原理 DDoS的攻击原理，往简单说，其实就是利用TCP/UDP协议规律，通过占用协议栈资源或者发起大流量拥塞，达到消耗目标机器性能或者网络的目的，下面我们先简单回顾TCP“三次握手”与“四次挥手”以及UDP通信流程。
TCP三次握手与四次挥手 TCP建立连接：三次握手
1.client: syn
2.server: syn+ack
3.client: ack
TCP断开连接：四次挥手
1.client: fin
2.server: ack
3.server: fin
4.client: ack 根据上图可发现，UDP通信是无连接、不可靠的，数据是直接传输的，并没有协商的过程。</description>
    </item>
    
    <item>
      <title>关于算法中的NP问题</title>
      <link>https://lochjin.github.io/posts/np/</link>
      <pubDate>Wed, 24 Jan 2018 20:01:58 +0800</pubDate>
      
      <guid>https://lochjin.github.io/posts/np/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://lochjin.github.io/img/2018/np.jpeg&#34; alt=&#34;np&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;关于算法中的NP问题&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>游戏服务器架构</title>
      <link>https://lochjin.github.io/posts/game-server/</link>
      <pubDate>Mon, 01 Jan 2018 17:12:58 +0800</pubDate>
      
      <guid>https://lochjin.github.io/posts/game-server/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://lochjin.github.io/img/2018/game-server.jpg&#34; alt=&#34;game&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;游戏服务器架构&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>GDI&#43; double buffer 绘图</title>
      <link>https://lochjin.github.io/posts/gdi&#43;doublebuffer/</link>
      <pubDate>Sun, 21 Nov 2010 10:31:40 +0800</pubDate>
      
      <guid>https://lochjin.github.io/posts/gdi&#43;doublebuffer/</guid>
      <description>问题 我在使用GDI+绘制控件的时候，如果频繁的刷新会很容易出现闪烁的问题，这是由于每一次画布的提交，都会造成窗口的刷新。
解决思路 于是我想能不能把多次提交暂存在一张虚拟的画布中，最后统一提交给窗口。
1. 首先在自己的频繁刷新的函数中创建一张后台画布： CClientDC dc(this); Graphics graphics(dc.GetSafeHdc()); CRect rect; GetClientRect(&amp;amp;rect); Bitmap bmp(rect.Width(),rect.Height()); m_pGraph=Graphics::FromImage(&amp;amp;bmp); 2. 然后将所有需要绘制到屏幕中的图片，文字等等会绘制到这张虚拟的画布中： DrawImageToBuffer(_T(&amp;#34;bg.jpg&amp;#34;),0,0,600,400); DrawTextToBuffer(_T(&amp;#34;bg1.jpg&amp;#34;),300,0,_T(&amp;#34;测试文字&amp;#34;),(int)wcslen(_T(&amp;#34;测试文字&amp;#34;)),12); float currTime = (float)timeGetTime(); float timeDelta = (currTime - lastTime)*0.001f; totalTime+=timeDelta; fcount+=1.0f; TCHAR textTemp[30]; wsprintf(textTemp,_T(&amp;#34;fps:%d/s\n&amp;#34;),(int)(fcount/totalTime)); DrawTextToBuffer(_T(&amp;#34;bg2.jpeg&amp;#34;),300,30,textTemp,(int)wcslen(textTemp),30); 3. 最后提交我们的画布到前台窗口中去： graphics.DrawImage(&amp;amp;bmp,rect.left,rect.top,rect.right,rect.bottom); m_pGraph=NULL; 4. OK，结束。按照这种方式，现在就不会再闪烁了。 注意：DrawImageToBuffer 和 DrawTextToBuffer 是我对GDI+封装的函数，完整代码如下：
// GDI+DoubleBufferDlg.cpp : 实现文件 // #include &amp;#34;stdafx.h&amp;#34; #include &amp;#34;GDI+DoubleBuffer.h&amp;#34; #include &amp;#34;GDI+DoubleBufferDlg.h&amp;#34; #include &amp;lt;ctime&amp;gt; #include&amp;lt;windows.h&amp;gt; #include &amp;lt;MMSystem.h&amp;gt; #pragma comment(lib,&amp;#34;Winmm.lib&amp;#34;) #ifdef _DEBUG #define new DEBUG_NEW #endif // 用于应用程序“关于”菜单项的 CAboutDlg 对话框 static float lastTime=0; static float totalTime=0; static float fcount=0; class CAboutDlg : public CDialog { public: CAboutDlg(); // 对话框数据 enum { IDD = IDD_ABOUTBOX }; protected: virtual void DoDataExchange(CDataExchange* pDX); // DDX/DDV 支持 // 实现 protected: DECLARE_MESSAGE_MAP() }; CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD) { } void CAboutDlg::DoDataExchange(CDataExchange* pDX) { CDialog::DoDataExchange(pDX); } BEGIN_MESSAGE_MAP(CAboutDlg, CDialog) END_MESSAGE_MAP() // CGDIDoubleBufferDlg 对话框 CGDIDoubleBufferDlg::CGDIDoubleBufferDlg(CWnd* pParent /*=NULL*/) : CDialog(CGDIDoubleBufferDlg::IDD, pParent) { m_hIcon = AfxGetApp()-&amp;gt;LoadIcon(IDR_MAINFRAME); } void CGDIDoubleBufferDlg::DoDataExchange(CDataExchange* pDX) { CDialog::DoDataExchange(pDX); } BEGIN_MESSAGE_MAP(CGDIDoubleBufferDlg, CDialog) ON_WM_SYSCOMMAND() ON_WM_PAINT() ON_WM_QUERYDRAGICON() //}}AFX_MSG_MAP ON_WM_TIMER() END_MESSAGE_MAP() // CGDIDoubleBufferDlg 消息处理程序 BOOL CGDIDoubleBufferDlg::OnInitDialog() { CDialog::OnInitDialog(); // 将“关于.</description>
    </item>
    
    <item>
      <title>Ogre WeaponTrail</title>
      <link>https://lochjin.github.io/posts/weapontrail/</link>
      <pubDate>Wed, 11 Feb 2009 14:11:58 +0800</pubDate>
      
      <guid>https://lochjin.github.io/posts/weapontrail/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://lochjin.github.io/img/2009/ogre.png&#34; alt=&#34;3d&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;A better realization of knife light class, here the idea is very worthy of learning. It can also be used to achieve ribbons.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title></title>
      <link>https://lochjin.github.io/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://lochjin.github.io/about/</guid>
      <description>For you, a thousand times over.</description>
    </item>
    
  </channel>
</rss>